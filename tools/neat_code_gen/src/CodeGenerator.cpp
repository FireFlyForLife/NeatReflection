#include "CodeGenerator.h"

#include "ContextualException.h"
#include "IfcRendering.h"
#include "StringOperations.h"

#include <format>
#include <cctype>
#include <algorithm>
#include <iostream>

#include "reflifc/Expression.h"
#include "reflifc/TemplateId.h"
#include "reflifc/decl/AliasDeclaration.h"
#include "reflifc/decl/Concept.h"
#include "reflifc/decl/Enumeration.h"
#include "reflifc/decl/Function.h"
#include "reflifc/decl/Intrinsic.h"
#include "reflifc/decl/Namespace.h"
#include "reflifc/decl/Parameter.h"
#include "reflifc/decl/TemplateDeclaration.h"
#include "reflifc/decl/UsingDeclaration.h"
#include "reflifc/type/Array.h"
#include "reflifc/type/Base.h"
#include "reflifc/type/Forall.h"
#include "reflifc/type/Function.h"
#include "reflifc/type/Pointer.h"
#include "reflifc/type/Placeholder.h"
#include "reflifc/type/Qualified.h"
#include "reflifc/type/Reference.h"

#include "ifc/Expression.h"
#include "ifc/File.h"
#include "ifc/Environment.h"

#include "magic_enum.hpp"


template <class T>
inline void hash_combine(std::size_t& seed, const T& v)
{
	std::hash<T> hasher;
	seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

size_t std::hash<reflifc::Declaration>::operator()(const reflifc::Declaration& decl) const
{
	// TODO: Submit patch to reflifc
	struct HackyDeclarationData
	{
		ifc::File const* ifc_;
		ifc::DeclIndex index_;
	};

	auto decl_data = (HackyDeclarationData&)decl;

	size_t seed = 0;
	hash_combine(seed, decl_data.ifc_);
	hash_combine(seed, decl_data.index_);
	return seed;
}

CodeGenerator::CodeGenerator(const ifc::File& ifc_file, ifc::Environment& environment)
	: ifc_file(&ifc_file)
	, environment(&environment)
{
	code.reserve(1024);
}

void CodeGenerator::write_cpp_file(reflifc::Module module, std::ostream& out)
{
	auto unit = module.unit();
	if (!unit.is_primary()) // For now
	{
		throw ContextualException("Currently the tool only supports primary module fragments (originating from a .ixx file from MSVC for example).");
	}

	const auto module_name = unit.name();
	
	ReflectableTypes reflectable_types{};
	scan(module.global_namespace(), reflectable_types);
	
	for (auto& reflectable_type : reflectable_types.types)
	{
		render(reflectable_type.second);
	}

	out << std::format(
R"(module;
#include "Neat/Reflection.h"
#include "Neat/TemplateTypeId.h"
module {0};

// ================================================================================
//                      AUTO GENERATED REFLECTION DATA FILE 
//                    Generated by: NeatReflectionCodeGen.exe
// 
//       Don't modify this file, it will be overwritten when a change is made.
// ================================================================================

namespace Neat
{{
	static void reflect_types_and_members()
	{{
{1}
	}}

	namespace
	{{
		struct Register{{ Register(){{ Neat::reflect_types_and_members(); }} }};
		static Register neat_reflection_data_initialiser{{ }};
	}}
}})", module_name, code);

	out.flush();
}

void CodeGenerator::scan(reflifc::Scope scope_desc, ReflectableTypes& out_types)
{
	auto declarations = scope_desc.get_declarations();
	for (auto declaration : declarations)
	{
		scan(declaration, out_types);
	}
}

void CodeGenerator::scan(reflifc::Declaration decl, ReflectableTypes& out_types)
{
	if (decl.is_scope())
		scan(decl.as_scope(), decl, out_types);
	else if (decl.is_template())
		scan(decl.as_template(), decl, out_types);
}

void CodeGenerator::scan(reflifc::TemplateDeclaration template_decl, reflifc::Declaration decl, ReflectableTypes& out_types)
{

}

void CodeGenerator::scan(reflifc::ScopeDeclaration scope_decl, reflifc::Declaration decl, ReflectableTypes& out_types)
{
	switch (scope_decl.kind())
	{
	case ifc::TypeBasis::Class:
	case ifc::TypeBasis::Struct:
		scan(scope_decl.as_class_or_struct(), decl, out_types);
		break;
	case ifc::TypeBasis::Union:
		// TODO: Implement at some point
		break;
	case ifc::TypeBasis::Namespace:
		scan(scope_decl.as_namespace().scope(), out_types);
		break;
	}
}

void CodeGenerator::scan(reflifc::ClassOrStruct scope_decl, reflifc::Declaration decl, ReflectableTypes& out_types)
{
	if (out_types.types.contains(decl))
	{
		return;
	}
	if (!is_type_visible_from_module(decl, reflifc::Module{ nullptr }, *environment))
	{
		auto typename__ = render_full_typename(decl, *environment);
		return;
	}

	ReflectableType type{ decl, scope_decl };

	// Mark this type as being visited, at the end of this function we will fill in the full member info.
	out_types.types.insert({ decl, type });

	const bool reflect_privates = can_reflect_private_members(decl, *environment);

	auto declarations = scope_decl.members();
	for (auto decl : declarations)
	{
		switch (decl.sort())
		{
		case ifc::DeclSort::Field:
		{
			const auto field = decl.as_field();

			if (is_member_publicly_accessible(field, scope_decl.kind(), reflect_privates, *environment))
			{
				type.fields.push_back(field);
				scan(field.type(), out_types);
			}
			break;
		}
		case ifc::DeclSort::Method:
		{
			const auto method = decl.as_method();
			
			if (is_member_publicly_accessible(method, scope_decl.kind(), reflect_privates, *environment))
			{
				type.methods.push_back(method);

				scan(method.type().return_type(), out_types);
				
				auto params = method.type().parameters();
				for (auto param : params)
				{
					scan(param, out_types);
				}
			}
			break;
		}
		}
	}

	auto bases = scope_decl.bases();
	for (auto base : bases)
	{
		if (is_type_visible_from_module(base.type, reflifc::Module{ nullptr }, *environment))
		{
			type.bases.push_back(base);
			scan(base.type, out_types);
		}
	}

	out_types.types.insert_or_assign(type.decl, std::move(type));
}

void CodeGenerator::scan(reflifc::Type type, ReflectableTypes& out_types)
{
	switch (type.sort())
	{
	case ifc::TypeSort::Fundamental: 
		break; // Currently we don't reflect integers n stuff, we need a declaration
	case ifc::TypeSort::Designated:
		scan(type.designation(), out_types);
		break;
	case ifc::TypeSort::Syntactic:
		scan(type.as_syntactic(), out_types);
		//scan(type.as_syntactic().primary(), out_types);
		//for (auto argument : type.as_syntactic().arguments())
		//{
		//	scan(argument, out_types);
		//}
		break;
	case ifc::TypeSort::Pointer:
		scan(type.as_pointer().pointee, out_types);
		break;
	case ifc::TypeSort::LvalueReference:
		scan(type.as_lvalue_reference().referee, out_types);
		break;
	case ifc::TypeSort::RvalueReference:
		scan(type.as_rvalue_reference().referee, out_types);
		break;
	case ifc::TypeSort::Function:
		scan(type.as_function().return_type(), out_types);
		for (auto parameter : type.as_function().parameters())
		{
			scan(parameter, out_types);
		}
		break;
	case ifc::TypeSort::Method:
		scan(type.as_method().return_type(), out_types);
		for (auto parameter : type.as_method().parameters())
		{
			scan(parameter, out_types);
		}
		break;
	case ifc::TypeSort::Array:
		scan(type.as_array().element(), out_types);
		break;
	case ifc::TypeSort::Qualified:
		scan(type.as_qualified().unqualified(), out_types);
		break;
	case ifc::TypeSort::Base:
		scan(type.as_base().type, out_types);
		break;
	case ifc::TypeSort::Tuple: // TODO: Is this a typelist? if so why can't we iterate it?
		break;
	case ifc::TypeSort::Forall:
		scan(type.as_forall().subject(), out_types);
		break;

		// Not currently supported:
	case ifc::TypeSort::Tor: // Compiler generated constructor
	case ifc::TypeSort::PointerToMember: // Not implemented yet by reflifc
	case ifc::TypeSort::Expansion:
	case ifc::TypeSort::Typename:
	case ifc::TypeSort::Decltype:
	case ifc::TypeSort::Placeholder:
	case ifc::TypeSort::Unaligned: // Not implemented yet by reflifc
	case ifc::TypeSort::SyntaxTree: // Not implemented yet by reflifc

	default:
		throw ContextualException(std::format("Unexpected type sort encountered while scanning: {}", 
			magic_enum::enum_name(type.sort())));
	}
}

void CodeGenerator::scan(reflifc::Expression expression, ReflectableTypes& out_types)
{
	switch (expression.sort())
	{
	case ifc::ExprSort::NamedDecl:
		scan(expression.referenced_decl(), out_types);
		break;
	case ifc::ExprSort::Type:
		scan(expression.as_type(), out_types);
		break;
	case ifc::ExprSort::TemplateId:
		scan(expression.as_template_id().primary(), out_types);
		for (auto argument : expression.as_template_id().arguments())
		{
			scan(argument, out_types);
		}
		break;
	
	default:
		// The rest we don't really care about, mostly syntactic expression sorts.
		break;
	}
}

void CodeGenerator::render(ReflectableType& type)
{
	const auto type_name = render_namespace(type.decl, *environment) + type.class_struct_decl.name().as_identifier();
	const bool reflect_privates = can_reflect_private_members(type.decl, *environment);
	const bool is_class = (type.class_struct_decl.kind() == ifc::TypeBasis::Class);

	std::string fields;
	fields.reserve(32 * type.fields.size());
	for (auto& field : type.fields)
	{
		fields += render_field(type_name, field);
		fields += ", ";
	}

	std::string methods;
	methods.reserve(32 * type.methods.size());
	for (auto& method : type.methods)
	{
		methods += render_method(type_name, method);
		methods += ", ";
	}

	std::string bases;
	bases.reserve(32 * type.bases.size());
	for (auto& base_class : type.bases)
	{
		bases += render_base_class(type_name, is_class, base_class);
		bases += ", ";
	}

	code += std::format(R"(add_type(Type::create<{0}>("{0}", get_id<{0}>(),
	{{ {1} }},
	{{ {2} }},
	{{ {3} }}
));
)", type_name, bases, fields, methods);
}

std::string CodeGenerator::render_field(std::string_view outer_class_type, const reflifc::Field& field) const
{
	auto type_sort = field.type().sort();
	const auto field_type = render_full_typename(field.type(), *environment);
	const auto name = field.name();
	const auto access = render_as_neat_access_enum(field.access(), "Access::...");

	return std::format(R"(Field::create<{0}, {1}, &{0}::{2}>("{2}", {3}))", outer_class_type, field_type, name, access);
}

std::string CodeGenerator::render_method(std::string_view outer_class_type, const reflifc::Method& method) const
{
	const auto method_type = method.type();
	const auto return_type = render_full_typename(method_type.return_type(), *environment);
	auto params = method_type.parameters();
	auto param_types = std::string{ "" };
	param_types.reserve(params.size() * 8);
	for (auto param : params)
	{
		param_types += ", ";
		param_types += render_full_typename(param, *environment);
	}
	const auto name = method.name().as_identifier();
	const auto access = render_as_neat_access_enum(method.access());
	
	return std::format(R"(Method::create<&{0}::{3}, {0}, {1}{2}>("{3}", {4}))", outer_class_type, return_type, param_types, name, access);
}

std::string CodeGenerator::render_base_class(std::string_view outer_class_type, bool outer_is_class, const reflifc::BaseType& base_class) const
{
	// If outer type is a class or struct, the default access is private or public
	const auto default_access = (outer_is_class ? "private" : "public");
	auto access_string = render_as_neat_access_enum(base_class.access, default_access);

	auto type_name = render_full_typename(base_class.type, *environment);

	return std::format(R"(BaseClass{{ get_id<{0}>(), {1} }})", type_name, access_string);
}

