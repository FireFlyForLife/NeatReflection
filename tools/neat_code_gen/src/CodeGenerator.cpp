#include "CodeGenerator.h"

#include "ContextualException.h"
#include "IfcConversion.h"
#include "IfcRendering.h"
#include "StringOperations.h"

#include <format>
#include <cctype>
#include <algorithm>
#include <iostream>

#include "reflifc/Expression.h"
#include "reflifc/TemplateId.h"
#include "reflifc/expr/Read.h"
#include "reflifc/expr/Path.h"
#include "reflifc/decl/AliasDeclaration.h"
#include "reflifc/decl/Concept.h"
#include "reflifc/decl/DeclarationReference.h"
#include "reflifc/decl/Enumeration.h"
#include "reflifc/decl/Function.h"
#include "reflifc/decl/Intrinsic.h"
#include "reflifc/decl/Namespace.h"
#include "reflifc/decl/Parameter.h"
#include "reflifc/decl/TemplateDeclaration.h"
#include "reflifc/decl/UsingDeclaration.h"
#include "reflifc/type/Array.h"
#include "reflifc/type/Base.h"
#include "reflifc/type/Forall.h"
#include "reflifc/type/Function.h"
#include "reflifc/type/Pointer.h"
#include "reflifc/type/Placeholder.h"
#include "reflifc/type/Qualified.h"
#include "reflifc/type/Reference.h"

#include "ifc/Expression.h"
#include "ifc/File.h"
#include "ifc/Environment.h"


using namespace std::string_literals;
using namespace std::string_view_literals;

CodeGenerator::CodeGenerator(const ifc::File& ifc_file, ifc::Environment& environment)
	: ifc_file(&ifc_file)
	, environment(&environment)
{
	code.reserve(4096);
}

void CodeGenerator::write_cpp_file(reflifc::Module module, std::ostream& out)
{
	// Get module name
	auto unit = module.unit();
	if (!unit.is_primary()) // For now
	{
		throw ContextualException("Currently this tool only supports primary module fragments (originating from a .ixx file from MSVC for example).");
	}

	const auto module_name = unit.name();
	
	// Scan module for all types that can be reflected
	ReflectableTypes reflectable_types{};
	{
		ContextArea scan_area{ "While scanning for types."sv };
		RecursionContext ctx{ environment, {} };

		try {
			scan(module.global_namespace(), ctx, reflectable_types);
		} catch (ContextualException& e) {
			std::cout << "Warning: Could not scan all types for module. Reason: " << e.what() << '\n';
		}
	}

	// Render reflectable types
	{
		ContextArea render_fundamental_area{ "While rendering fundamental types."sv };
		for (auto& reflectable_fundamental_type : reflectable_types.fundamental_types) {
			try {
				render(reflectable_fundamental_type.as_fundamental());
			} catch (ContextualException& e) {
				std::cout << "Warning: Could not render fundamental type. Reason: " << e.what() << '\n';
			}
		}
	}
	
	{
		ContextArea render_area{ "While rendering types."sv };
		for (auto& reflectable_type : reflectable_types.types) {
			try {
				const bool is_templated_type = false;
				render(reflectable_type.second, is_templated_type);
			} catch (ContextualException& e) {
				std::cout << "Warning: Could not render type. Reason: " << e.what() << '\n';
			}
		}
	}

	{
		ContextArea render_area{ "While rendering templated types."sv };
		for (auto& reflectable_templated_type : reflectable_types.template_types) {
			try {
				const bool is_templated_type = true;
				render(reflectable_templated_type.second, is_templated_type);
			} catch (ContextualException& e) {
				std::cout << "Warning: Could not render templated type. Reason: " << e.what() << '\n';
			}
		}
	}

	// Write the generated code to the output stream
	out << std::format(
R"(module;
#include "Neat/Reflection.h"
#include "Neat/TemplateTypeId.h"
module {0};

// ================================================================================
//                      AUTO GENERATED REFLECTION DATA FILE 
//                    Generated by: NeatReflectionCodeGen.exe
// 
//       Don't modify this file, it will be overwritten when a change is made.
// ================================================================================

namespace Neat
{{
	static void reflect_types_and_members()
	{{
{1}
	}}

	namespace
	{{
		struct Register{{ Register(){{ Neat::reflect_types_and_members(); }} }};
		static Register neat_reflection_data_initialiser{{ }};
	}}
}})", module_name, code);

	out.flush();
}

void CodeGenerator::scan(reflifc::Scope scope_desc, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	auto declarations = scope_desc.get_declarations();
	for (auto declaration : declarations)
	{
		try {
			scan(declaration, ctx, out_types);
		} catch (ContextualException& e) { 
			std::cout << "Warning: Could not scan declaration, will be skipping it. Reason: " << e.what() << '\n';
		}
	}
}

void CodeGenerator::scan(reflifc::Declaration decl, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	if (decl.is_scope())
		scan(decl.as_scope(), decl, ctx, out_types);
}

void CodeGenerator::scan(reflifc::ScopeDeclaration scope_decl, reflifc::Declaration decl, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	switch (scope_decl.kind())
	{
	case ifc::TypeBasis::Class:
	case ifc::TypeBasis::Struct:
		scan(scope_decl.as_class_or_struct(), decl, ctx, out_types);
		break;
	case ifc::TypeBasis::Union:
		// TODO: Implement at some point
		break;
	case ifc::TypeBasis::Namespace:
		scan(scope_decl.as_namespace().scope(), ctx, out_types);
		break;
	}
}
static bool is_reference_type(reflifc::Type type, RecursionContextArg ctx);
static bool is_reference_type(reflifc::Declaration decl, RecursionContextArg ctx)
{
	if (decl.is_reference()) {
		return is_reference_type(decl.as_reference().referenced_declaration(*ctx.environment), ctx);
	}
	if (decl.is_parameter()) {
		auto[argument, new_ctx] = ctx.get_template_parameter(decl.as_parameter());
		verify(argument.is_type()); // TODO: what if this is another parameter?
		return is_reference_type(argument.as_type(), new_ctx);
	}

	return false;
}

static bool is_reference_type(reflifc::Type type, RecursionContextArg ctx)
{
	if (type.is_lvalue_reference() || type.is_rvalue_reference()) {
		return true;
	}

	if (type.is_designated()) {
		return is_reference_type(type.designation(), ctx);
	}

	return false;
}

void CodeGenerator::scan(reflifc::ClassOrStruct scope_decl, reflifc::Declaration decl, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	if (out_types.types.contains(decl)) {
		return;
	}
	if (!is_type_visible_from_module(decl, reflifc::Module{ ifc_file }, ctx)) {
		return;
	}

	ReflectableType type{ };
	type.type_name = render_full_typename(decl, ctx);
	type.default_access = scope_decl.access();

	// Mark this type as being visited, at the end of this function we will fill in the full member info.
	out_types.types.insert({ decl, type });

	const bool reflect_privates = can_reflect_private_members(decl, reflifc::Module{ifc_file}, ctx);

	auto declarations = scope_decl.members();
	for (auto decl : declarations)
	{
		switch (decl.sort())
		{
		case ifc::DeclSort::Field:
		{
			const auto field = decl.as_field();

			if (!is_reference_type(field.type(), ctx) 
				&& is_member_publicly_accessible(field, scope_decl.kind(), reflect_privates, reflifc::Module{ ifc_file }, ctx))
			{
				type.fields.push_back(field);
				scan(field.type(), ctx, out_types);
			}
			break;
		}
		case ifc::DeclSort::Method:
		{
			const auto method = decl.as_method();
			
			if (!method.name().is_conversion()
				&& is_member_publicly_accessible(method, scope_decl.kind(), reflect_privates, reflifc::Module{ ifc_file }, ctx))
			{
				type.methods.push_back(method);

				scan(method.type().return_type(), ctx, out_types);
				
				auto params = method.type().parameters();
				for (auto param : params)
				{
					scan(param, ctx, out_types);
				}
			}
			break;
		}
		case ifc::DeclSort::Alias:
		{
			const auto alias = decl.as_alias();
			
			if (is_member_publicly_accessible(alias, scope_decl.kind(), reflect_privates, reflifc::Module{ ifc_file }, ctx)) {
				type.aliases.push_back(alias);
				scan(alias.aliasee(), ctx, out_types);
			}

			break;
		}
		}
	}

	auto bases = scope_decl.bases();
	for (auto base : bases)
	{
		if (is_type_visible_from_module(base.type, reflifc::Module{ ifc_file }, ctx))
		{
			type.bases.push_back(base);
			scan(base.type, ctx, out_types);
		}
	}

	out_types.types.insert_or_assign(decl, std::move(type));
}

static bool is_concrete_fundamental_type(ifc::TypeBasis type)
{
	switch(type) {
	case ifc::TypeBasis::Void:
	case ifc::TypeBasis::Bool:
	case ifc::TypeBasis::Char:
	case ifc::TypeBasis::Wchar_t:
	case ifc::TypeBasis::Int:
	case ifc::TypeBasis::Float:
	case ifc::TypeBasis::Double:
	case ifc::TypeBasis::Nullptr:
		return true;
	default:
		return false;
	}
}

void CodeGenerator::scan(reflifc::Type type, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	switch (type.sort())
	{
	case ifc::TypeSort::Fundamental:
		assert(is_concrete_fundamental_type(type.as_fundamental().basis));
		out_types.fundamental_types.insert(type);
	break;
	case ifc::TypeSort::Designated:
		scan(type.designation(), ctx, out_types);
		break;
	case ifc::TypeSort::Tor: // Compiler generated constructor, implemented in NeatReflection runtime library
		break;
	case ifc::TypeSort::Syntactic:
		scan(type.as_syntactic(), ctx, out_types);
		break;
	case ifc::TypeSort::Pointer:
		scan(type.as_pointer().pointee, ctx, out_types);
		break;
	case ifc::TypeSort::LvalueReference:
		scan(type.as_lvalue_reference().referee, ctx, out_types);
		break;
	case ifc::TypeSort::RvalueReference:
		scan(type.as_rvalue_reference().referee, ctx, out_types);
		break;
	case ifc::TypeSort::Function:
		scan(type.as_function().return_type(), ctx, out_types);
		for (auto parameter : type.as_function().parameters()) {
			scan(parameter, ctx, out_types);
		}
		break;
	case ifc::TypeSort::Method:
		scan(type.as_method().return_type(), ctx, out_types);
		for (auto parameter : type.as_method().parameters()) {
			scan(parameter, ctx, out_types);
		}
		break;
	case ifc::TypeSort::Array:
		scan(type.as_array().element(), ctx, out_types);
		break;
	case ifc::TypeSort::Typename:
		if (auto resolved_type = resolve_type(type.typename_path(), ctx)) { // TODO: This should probably update ctx too?
			scan(resolved_type, ctx, out_types);
		}
		break;
	case ifc::TypeSort::Qualified:
		scan(type.as_qualified().unqualified(), ctx, out_types);
		break;
	case ifc::TypeSort::Base:
		scan(type.as_base().type, ctx, out_types);
		break;
	case ifc::TypeSort::Tuple: // TODO: Is this a typelist? if so why can't we iterate it?
		break;
	case ifc::TypeSort::Forall:
		scan(type.as_forall().subject(), ctx, out_types);
		break;

		// Not currently supported:
	case ifc::TypeSort::PointerToMember: // Not implemented yet by reflifc
	case ifc::TypeSort::Expansion:
	case ifc::TypeSort::Decltype:
	case ifc::TypeSort::Placeholder:
	case ifc::TypeSort::Unaligned: // Not implemented yet by reflifc
	case ifc::TypeSort::SyntaxTree: // Not implemented yet by reflifc

	default:
		throw ContextualException(std::format("Unexpected type sort encountered while scanning: {}", 
			type_sort_to_string(type.sort())));
	}
}

void CodeGenerator::scan(reflifc::Expression expression, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	switch (expression.sort())
	{
	case ifc::ExprSort::NamedDecl:
		scan(expression.referenced_decl(), ctx, out_types);
		break;
	case ifc::ExprSort::Type:
		scan(expression.as_type(), ctx, out_types);
		break;
	case ifc::ExprSort::TemplateId:
		scan(expression.as_template_id(), ctx, out_types);
		break;
	
	default:
		// The rest we don't really care about, mostly syntactic expression sorts.
		break;
	}
}

void CodeGenerator::scan(reflifc::TemplateId template_id, RecursionContextArg ctx, ReflectableTypes& out_types)
{
	if (out_types.template_types.contains(template_id)) {
		return;
	}
	if (!is_type_visible_from_module(template_id, reflifc::Module{ ifc_file }, ctx)) {
		return;
	}

	if (!template_id.primary().is_qualref() || !template_id.primary().referenced_decl().is_template()) {
		return;
	}
	
	auto templated_decl = template_id.primary().referenced_decl();
	auto template_declaration = templated_decl.as_template();
	
	RecursionContext new_ctx{ ctx };
	auto arguments = template_id.arguments();
	new_ctx.template_argument_sets.emplace_back(arguments.begin(), arguments.end());
	auto template_entity = resolve_template_entity(template_declaration, new_ctx);

	if (template_entity.is_class_or_struct()) {
		auto class_or_struct = template_entity.as_class_or_struct();
		
		ReflectableType template_type;
		template_type.type_name = render_full_typename(template_id, ctx);
		template_type.templates_context = new_ctx;
		template_type.default_access = class_or_struct.access();

		// Mark this type as visited, will be fill in at the end of this function
		out_types.template_types.insert({ template_id, template_type });

		const bool reflect_privates = can_reflect_private_members(templated_decl, reflifc::Module{ ifc_file }, new_ctx);

		for (auto decl : class_or_struct.members()) {
			switch (decl.sort()) {
			case ifc::DeclSort::Field:
			{
				const auto field = decl.as_field();

				if (!is_reference_type(field.type(), new_ctx)
					&& is_member_publicly_accessible(field, class_or_struct.kind(), reflect_privates, reflifc::Module{ ifc_file }, new_ctx)) {
					template_type.fields.push_back(field);
					scan(field.type(), new_ctx, out_types);
				}
				break;
			}
			case ifc::DeclSort::Method:
			{
				const auto method = decl.as_method();

				if (!method.name().is_conversion()
					&& is_member_publicly_accessible(method, class_or_struct.kind(), reflect_privates, reflifc::Module{ ifc_file }, new_ctx)) {
					template_type.methods.push_back(method);

					scan(method.type().return_type(), new_ctx, out_types);

					auto params = method.type().parameters();
					for (auto param : params) {
						scan(param, new_ctx, out_types);
					}
				}
				break;
			}
			case ifc::DeclSort::Alias:
			{
				const auto alias = decl.as_alias();

				if (is_member_publicly_accessible(alias, class_or_struct.kind(), reflect_privates, reflifc::Module{ ifc_file }, new_ctx)) {
					template_type.aliases.push_back(alias);
					scan(alias.aliasee(), new_ctx, out_types);
				}

				break;
			}
			}
		}

		auto bases = class_or_struct.bases();
		for (auto base : bases) {
			if (is_type_visible_from_module(base.type, reflifc::Module{ ifc_file }, new_ctx)) {
				template_type.bases.push_back(base);
				scan(base.type, new_ctx, out_types);
			}
		}

		out_types.template_types.insert_or_assign(template_id, template_type);
	}

	// Continue scanning it's template arguments
	for (auto argument : template_id.arguments()) {
		scan(argument, ctx, out_types);
	}
}

void CodeGenerator::render(const ifc::FundamentalType& type)
{
	// Edge case, sizeof(void) doesn't compile
	if (type.basis == ifc::TypeBasis::Void) {
		code += R"(add_type(Type{ .name="void", .id=get_id<void>(), .size=0 });
)"sv;
		return;
	}

	auto type_name = render_full_typename(type);

	code += std::format(R"(add_type(Type{{ .name="{0}", .id=get_id<{0}>(), .size=sizeof({0}) }});
)", type_name);
}

void CodeGenerator::render(ReflectableType& type, bool is_templated_type)
{
	auto& ctx = type.templates_context;
	// TODO: don't store RecursionContext directly in ReflectableType, so we don't have to awkwardly fill in the environment here
	ctx.environment = environment;

	std::string fields;
	fields.reserve(32 * type.fields.size());
	for (auto& field : type.fields) {
		fields += render_field(type.type_name, type.default_access, field, ctx);
		fields += ", ";
	}

	std::string methods;
	methods.reserve(32 * type.methods.size());
	for (auto& method : type.methods) {
		methods += render_method(type.type_name, type.default_access, method, ctx);
		methods += ", ";
	}

	std::string bases;
	bases.reserve(32 * type.bases.size());
	for (auto& base_class : type.bases) {
		bases += render_base_class(type.type_name, type.default_access, base_class, ctx);
		bases += ", ";
	}

	std::string aliases;
	aliases.reserve(32 * type.aliases.size());
	for (auto& alias : type.aliases) {
		aliases += render_member_alias(alias, type.default_access, ctx);
		aliases += ", ";
	}

	std::string template_arguments;
	if (is_templated_type) {
		template_arguments.reserve(32 * ctx.template_argument_sets.size());

		RecursionContext previous_context = ctx;
		previous_context.template_argument_sets.pop_back();

		for (const auto& template_arg : ctx.template_argument_sets.back()) {
			template_arguments += render_template_argument(template_arg, previous_context);
			template_arguments += ", ";
		}
	}

	code += std::format(R"(add_type(Type::create<{0}>("{0}", get_id<{0}>(),
	{{ {1} }},
	{{ {2} }},
	{{ {3} }},
	{{ {4} }},
	{{ {5} }}
));
)", type.type_name, bases, fields, methods, aliases, template_arguments);
}

std::string CodeGenerator::render_field(std::string_view outer_class_type, ifc::Access default_access, const reflifc::Field& field, RecursionContextArg ctx) const
{
	const auto field_type = render_full_typename(field.type(), ctx);
	const auto name = field.name();
	const auto access = render_as_neat_access_enum(field.access(), default_access);

	return std::format(R"(Field::create<{0}, {1}, &{0}::{2}>("{2}", {3}))", outer_class_type, field_type, name, access);
}

std::string CodeGenerator::render_method(std::string_view outer_class_type, ifc::Access default_access, const reflifc::Method& method, RecursionContextArg ctx) const
{
	const auto method_type = method.type();
	const auto return_type = render_full_typename(method_type.return_type(), ctx);
	const auto params = render_full_typename_list(method_type.parameters(), ctx);
	const auto begin_params_delimiter = (params.empty() ? ""sv : ", "sv);
	const auto name = render_name(method.name(), ctx);
	const auto access = render_as_neat_access_enum(method.access(), default_access);
	const auto method_ptr_type = render_method_pointer(method_type, outer_class_type, ctx);
	
	return std::format(R"(Method::create<({6})&{0}::{4}, {0}, {1}{2}{3}>("{4}", {5}))", outer_class_type, return_type, begin_params_delimiter, params, name, access, method_ptr_type);
}

std::string CodeGenerator::render_base_class(std::string_view outer_class_type, ifc::Access default_access, const reflifc::BaseType& base_class, RecursionContextArg ctx) const
{
	// If outer type is a class or struct, the default access is private or public
	auto access_string = render_as_neat_access_enum(base_class.access, default_access);

	auto type_name = render_full_typename(base_class.type, ctx);

	return std::format(R"(BaseClass{{ get_id<{0}>(), {1} }})", type_name, access_string);
}

std::string CodeGenerator::render_member_alias(const reflifc::AliasDeclaration& member_alias, ifc::Access default_access, RecursionContextArg ctx) const
{
	auto alias_name = member_alias.name();
	const auto field_type = render_full_typename(member_alias.aliasee(), ctx);
	const auto access = render_as_neat_access_enum(member_alias.access(), default_access);

	return std::format(R"(TypeAlias{{ "{0}", get_id<{1}>(), {2} }})", alias_name, field_type, access);
}

std::string CodeGenerator::render_template_argument(const reflifc::Expression& template_arg, RecursionContextArg ctx) const
{
	std::string rendered_argument;
	bool is_type_argument;

	switch (template_arg.sort()) {
		// Expression type refers to a non-type template parameter
	case ifc::ExprSort::Read:
		rendered_argument = render_full_typename(template_arg.as_read().address(), ctx); // TODO: Also cast to the correct integer type, needs to be obtained from the TemplateDecl
		is_type_argument = false;
		break;
	case ifc::ExprSort::Literal:
		rendered_argument = render_full_typename(template_arg.as_literal());
		is_type_argument = false;
		break;

		// Expression type refers to a type template parameter
	case ifc::ExprSort::NamedDecl:
		rendered_argument = render_full_typename(template_arg.referenced_decl(), ctx);
		is_type_argument = true;
		break;
	case ifc::ExprSort::Type:
		rendered_argument = render_full_typename(template_arg.as_type(), ctx);
		is_type_argument = true;
		break;
	case ifc::ExprSort::TemplateId:
		rendered_argument = render_full_typename(template_arg.as_template_id(), ctx);
		is_type_argument = true;
		break;

		// This function is only for rendering a template parameter, most expression sorts are not used for that so will be ignored:
	default:
		throw ContextualException{ std::format("Unexpected expression while rendering typename. ExprSort is: {}",
			expr_sort_to_string(template_arg.sort())) };
	}
	
	if (is_type_argument)
		return std::format("TemplateArgument{{ Neat::get_id<{0}>() }}", rendered_argument);
	else
		return std::format("TemplateArgument{{ Neat::Any{{ {0} }} }}", rendered_argument);
}
