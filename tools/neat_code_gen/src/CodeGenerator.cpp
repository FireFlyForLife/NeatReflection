#include "CodeGenerator.h"

#include "ContextualException.h"
#include "IfcRendering.h"
#include "StringOperations.h"

#include <format>
#include <cctype>
#include <algorithm>
#include <iostream>

#include "reflifc/Expression.h"
#include "reflifc/TemplateId.h"
#include "reflifc/decl/AliasDeclaration.h"
#include "reflifc/decl/ClassOrStruct.h"
#include "reflifc/decl/Concept.h"
#include "reflifc/decl/Enumeration.h"
#include "reflifc/decl/Function.h"
#include "reflifc/decl/Intrinsic.h"
#include "reflifc/decl/Namespace.h"
#include "reflifc/decl/Parameter.h"
#include "reflifc/decl/TemplateDeclaration.h"
#include "reflifc/decl/UsingDeclaration.h"
#include "reflifc/type/Function.h"
#include "reflifc/type/Pointer.h"
#include "reflifc/type/Placeholder.h"
#include "reflifc/type/Qualified.h"
#include "reflifc/type/Reference.h"

#include "ifc/Expression.h"
#include "ifc/File.h"
#include "ifc/Environment.h"

#include "magic_enum.hpp"


CodeGenerator::CodeGenerator(const ifc::File& ifc_file, ifc::Environment& environment)
	: ifc_file(&ifc_file)
	, environment(&environment)
{
	code.reserve(1024);
}

void CodeGenerator::write_cpp_file(reflifc::Module module, std::ostream& out)
{
	auto unit = module.unit();
	if (!unit.is_primary()) // For now
	{
		throw ContextualException("Currently the tool only supports primary module fragments (originating from a .ixx file from MSVC for example).");
	}

	const auto module_name = unit.name();
	
	scan(module.global_namespace());
	
	out << std::format(
R"(// ================================================================================
//                      AUTO GENERATED REFLECTION DATA FILE 
//                    Generated by: NeatReflectionCodeGen.exe
// 
//       Don't modify this file, it will be overwritten when a change is made.
// ================================================================================

#include "Neat/Reflection.h"
#include "Neat/TemplateTypeId.h"

import {0};


namespace Neat
{{
	static void reflect_private_members()
	{{
{1}
	}}

	namespace
	{{
		struct Register{{ Register(){{ Neat::reflect_private_members(); }} }};
		static Register neat_reflection_data_initialiser{{ }};
	}}
}})", module_name, code);

	out.flush();
}

void CodeGenerator::scan(reflifc::Scope scope_desc)
{
	auto declarations = scope_desc.get_declarations();
	for (auto declaration : declarations)
	{
		scan(declaration);
	}
}

void CodeGenerator::scan(reflifc::Declaration decl)
{
	if (decl.is_scope())
		scan(decl.as_scope(), decl);
}

void CodeGenerator::scan(reflifc::ScopeDeclaration scope_decl, reflifc::Declaration decl)
{
	switch (scope_decl.kind())
	{
	case ifc::TypeBasis::Class:
	case ifc::TypeBasis::Struct:
		{
			render(scope_decl.as_class_or_struct(), decl);
		}
		break;
	case ifc::TypeBasis::Union:
		// TODO: Implement at some point
		break;
	case ifc::TypeBasis::Namespace:
		scan(scope_decl.as_namespace().scope());
		break;
	}
}

void CodeGenerator::render(reflifc::ClassOrStruct scope_decl, reflifc::Declaration decl)
{
	if(!is_type_exported(decl))
	{
		return;
	}

	const auto type_name = render_namespace(decl) + scope_decl.name().as_identifier();
	const auto var_name = to_snake_case(type_name) + '_';
	const bool reflect_privates = reflects_private_members(decl);
	const auto [fields, methods] = render_members(type_name, var_name, scope_decl, reflect_privates);
	const auto bases = render_bases(scope_decl);

	code += std::format(R"(add_type({{ "{1}", get_id<{1}>(),
	{{ {2} }},
	{{ {3} }},
	{{ {4} }}
}});
)", var_name, type_name, bases, fields, methods);
}

CodeGenerator::TypeMembers CodeGenerator::render_members(std::string_view type_name, std::string_view type_variable, reflifc::ClassOrStruct scope_decl, bool reflect_private_members)
{
	std::string fields;
	std::string methods;

	auto declarations = scope_decl.members();
	for (auto decl : declarations)
	{
		switch (decl.sort())
		{
		case ifc::DeclSort::Field:
		{
			const auto field = decl.as_field();
			const auto type = render_full_typename(field.type());
			const auto name = field.name();
			const auto access = render_as_neat_access_enum(field.access(), "Access::...");

			if (is_member_publicly_accessible(field, scope_decl.kind(), reflect_private_members))
			{
				fields += std::format(R"(Field::create<{0}, {1}, &{0}::{2}>("{2}", {3}), )", type_name, type, name, access);
			}
			break;
		}
		case ifc::DeclSort::Method:
		{
			const auto method = decl.as_method();
			const auto method_type = method.type();
			const auto return_type = render_full_typename(method_type.return_type());
			auto params = method_type.parameters();
			auto param_types = std::string{ "" };
			param_types.reserve(params.size() * 8);
			for (auto param : params)
			{
				param_types += ", ";
				param_types += render_full_typename(param);
			}
			const auto name = method.name().as_identifier();
			const auto access = render_as_neat_access_enum(method.access());

			if (is_member_publicly_accessible(method, scope_decl.kind(), reflect_private_members))
			{
				methods += std::format(R"(Method::create<&{0}::{3}, {0}, {1}{2}>("{3}", {4}), )", type_name, return_type, param_types, name, access);
			}
			break;
		}
		}
	}
	return { fields, methods };
}

std::string CodeGenerator::render_bases(reflifc::ClassOrStruct scope_decl)
{
	// Otherwise struct
	const bool is_class = (scope_decl.kind() == ifc::TypeBasis::Class);
	const auto default_access = (is_class ? "private" : "public");

	auto bases = scope_decl.bases();

	std::string rendered;
	rendered.reserve(bases.size() * 16);

	for (auto type : bases)
	{
		auto access_string = render_as_neat_access_enum(type.access, default_access);
		auto type_name = render_full_typename(type.type);
		rendered += std::format(R"(BaseClass{{ get_id<{0}>(), {1} }}, )", type_name, access_string);
	}

	return rendered;
}
